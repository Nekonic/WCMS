{% extends 'base.html' %}

{% block title %}프로세스 기록 - {{ pc.hostname }}{% endblock %}

{% block content %}

<div class="history-container">
    <h2 class="history-header">프로세스 사용 기록: {{ pc.hostname }}</h2>
    <table class="history-table" id="historyTable">
        <thead>
            <tr>
                <th>시간</th>
                <th>사용자</th>
                <th>실행된 프로세스</th>
            </tr>
        </thead>
        <tbody>
            <!-- 데이터가 여기에 동적으로 추가됩니다. -->
        </tbody>
    </table>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
function formatDate(dateString) {
    if (!dateString) return 'N/A';

    // SQLite 날짜 형식 (YYYY-MM-DD HH:MM:SS)을 ISO 8601 (YYYY-MM-DDTHH:MM:SSZ)로 변환
    // UTC로 가정하고 Z를 붙임
    const isoString = dateString.replace(' ', 'T') + 'Z';

    try {
        const date = new Date(isoString);
        if (isNaN(date.getTime())) {
            // 파싱 실패 시 원본 반환 또는 다른 시도
            return dateString;
        }
        return date.toLocaleString();
    } catch (e) {
        return dateString;
    }
}

document.addEventListener("DOMContentLoaded", function() {
    const pcId = {{ pc.id }};
    fetch(`/api/pc/${pcId}/history`)
        .then(response => response.json())
        .then(data => {
            const tableBody = document.querySelector("#historyTable tbody");
            if (data.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="3" class="text-center-msg">기록이 없습니다.</td></tr>';
                return;
            }

            let rowsHtml = '';
            data.forEach(record => {
                let processesHtml = '<span class="text-none">없음</span>';
                if (record.processes) {
                    try {
                        // 이중 JSON 인코딩 처리
                        let processesData = record.processes;

                        // 문자열이면 파싱 시도 (재귀적으로)
                        while (typeof processesData === 'string') {
                            try {
                                processesData = JSON.parse(processesData);
                            } catch(e) {
                                break;
                            }
                        }

                        // 배열인지 확인
                        if (Array.isArray(processesData) && processesData.length > 0) {
                            processesHtml = processesData.map(p => `<span class="badge">${p}</span>`).join('');
                        }
                    } catch(e) {
                        console.error('Process parsing error:', e, record.processes);
                        processesHtml = '<span class="text-error">파싱 오류</span>';
                    }
                }

                // updated_at 필드 사용 (API가 updated_at을 반환함)
                const timeStr = record.updated_at || record.created_at;

                const row = `
                    <tr>
                        <td>${formatDate(timeStr)}</td>
                        <td>${record.current_user || 'N/A'}</td>
                        <td>${processesHtml}</td>
                    </tr>
                `;
                rowsHtml += row;
            });
            tableBody.innerHTML = rowsHtml;
        })
        .catch(error => {
            console.error('Error fetching process history:', error);
            const tableBody = document.querySelector("#historyTable tbody");
            tableBody.innerHTML = '<tr><td colspan="3" class="text-center-msg text-error">데이터를 불러오는 중 오류가 발생했습니다.</td></tr>';
        });
});
</script>
{% endblock %}
